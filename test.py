#coding:utf-8

import socket
import numpy as np
from matplotlib import pyplot as plt


# check whether the port is in use
def checkPort(port, host = '127.0.0.1'):
    s = None
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(10)
        s.connect((host, int(port)))
        return True
    except:
        return False
    finally:
        if s:
            s.close()

# host = '10.37.100.16'
# port = 16944
# print(checkPort(port, host))


'''
KF steps:
1. init: estimate value, cov matrix: P0
while (int i = 0; i <= n; i++) {
    2. predict value update: x = Ax+Bu
    3. new cov matrix(predict value and real value): P = APA.T+Q (Q is the noise matrix)
    4. Kalman increment update: K = PH.T(HPH.T+R)^(-1)
    5. estimate value update: x = x(predict value) + K(z-Hx(predict value))
    6. cov matrix between estimate value and real value update: P = (I-KH)P(cov matrix between predict value and real value)
'''



class KalmanFilter():
    def __init__(self):
        # 初始化这些矩阵
        self.delta_t = 0.1
        self.t = np.linspace(0, 10, num = int(10 / self.delta_t))   # list for the time interval
        self.N = len(self.t)
        self.sz = [2, self.N]
        self.g = self.q = 10 # gravity accelerate and system inner noise variance
        self.Q = np.array([[self.q, 0], [0,0]]) # noise 2*2 position and speed
        self.r = 5 # measure noise variance
        self.R = [self.r]  # cov_variance measure the speed
        self.A = np.array([[1, self.delta_t], [0, 1]])  # position matrix
        self.B = np.array([[1/2*pow(self.delta_t, 2)], [self.delta_t]]) # control matrix, 2*1
        self.H = np.array([[1,0]]) # measure matrix, 1*2

        self.n = np.shape(self.Q)
        self.m = len(self.R)

        self.P = np.zeros(self.n)  # cov_matrix (estimate and real)
        self.Qn = np.zeros((1, self.N))  # cummulative bias generated by system noise

    def testQn(self):
        # randn是满足高斯分布的随机数
        self.Qn[0, 0] = np.sqrt(self.q)*np.random.randn()
        for i in range(2, self.N):
            self.Qn[0, i] = self.Qn[0, i-1] + np.sqrt(self.q) * np.random.randn()
        return self.Qn


    def kalmanProcess(self, counter):
        Qn = self.testQn()
        # the function of real value = [1/2*g*t^2, Qn[times/delta_t] ]
        # z = 1*100向量，x
        x = []
        for i in self.t:
            x.append(1/2*self.g*pow(i, 2) + Qn[0, int(i/self.delta_t-1)])

        # x = 1/2*self.g*pow(times, 2) + Qn[0, int(times / self.delta_t)-1]  # real value
        z = x + np.sqrt(self.r) * np.random.randn(1, self.N)  # observe value bu adding noise
        #
        xhat = xhatminus = np.zeros(self.sz)
        Pminus = np.zeros(self.n)
        K = np.zeros((self.n[0], self.m))   # 2*1
        I = np.eye(self.n[0])  # eye is the unit matrix


        while counter <= self.N-1:
            xhatminus[:, counter] = np.dot(self.A, xhat[:, counter-1]) + (self.B * self.g).T
            Pminus = np.dot(np.dot(self.A, self.P), self.A.T) + self.Q
            # non-square matrix uses singular decompose, square matrix uses inv function
            # K是卡尔曼增益矩阵，P和Pminus是三个量两两之间的协方差矩阵
            K = np.dot(np.dot(Pminus, self.H.T), np.linalg.inv(np.dot(np.dot(self.H, Pminus), self.H.T) + self.R))
            xhat[:, counter] = xhatminus[:, counter] + np.dot(K, (z[0, counter]-np.dot(self.H, xhatminus[:, counter])))
            self.P = np.dot((I - np.dot(K, self.H)), Pminus)
            # xhatminusls.append(xhatminus[:, counter][0])
            # xhatls.append(xhat[:, counter][0])


            counter += 1
        return xhat, xhatminus, x, z


    def fig(self, counter):
        xhat, xhatminus, x, z = self.kalmanProcess(counter)
        fig, ax = plt.subplots()
        # ax.plot(xhat[1, :], xhat[0, :], 'r', label = 'estimate-value line')
        ax.plot(xhat[1,:], xhatminus[0, :], 'g', label = "predict-value line")
        ax.plot(xhat[1, :], x, 'y', label="real-value line")
        # ax.plot(xhat[1, :], z[0,:], 'b', label="observation-value line")
        plt.title("comparison for 4 lines")
        plt.xlabel('time from 0')
        plt.ylabel('value range')
        plt.show()
        

        return 0

kf = KalmanFilter()

print(kf.fig(counter = 9))
# print(np.random.randn(1, 100))